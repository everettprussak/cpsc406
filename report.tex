\documentclass{article}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-406 Report}
\author{Everett Prussak  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Consisting of CPSC 406 Material at Chapman University with Professor Alexander Kurz. This report will include an Introduction, Weekly Homework, and a Paper on the group project, which is done throughout the semester. 
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}
This report...

\section{Homework}\label{homework}

This section contains solutions to homework. 

\subsection{Week 2 (Homework 1)}
This week's homework was to solve the following NFA:\noindent\newline
\includegraphics[scale=0.8]{a}\noindent\newline
\noindent\newline This is the following NFA but drawn out:

\includegraphics[scale=0.2]{nfa}\noindent\newline

From this NFA, the following DFA table can be made:\noindent\newline
\includegraphics[scale=0.8]{b}\noindent\newline

\includegraphics[scale=0.2]{dfa}\noindent\newline

\noindent\newline\newline This DFA diagram will allow for the correct initial state, final states, and correct path for each input.


\subsection{Week 3 (Homework 2)}
\noindent Week 3 consisted of 2 Questions. They are in their respective sections.\newline

\subsubsection{Question 1}
For Week 3 Question the object was to write the steps of the unification algorithm for each pair. \newline

\includegraphics[scale=0.75]{c}\noindent\newline

\noindent\newline For number 1 of question 1 I got the following answer:

\begin{verbatim}
1. f(X,f(X,Y)) = f(f(Y,a),f(U,b))

  1. X = f(Y,a)
      o1 = [f(Y,a)/X]

  2. f(X,Y) = f(U,b)
      3. X = U
          o3 = [U/X]
      4. Y = b
          o4 = [b/Y]

  5. X(o3 * o4) = U, f(o3 * o4)(Y,a) = f(b,a)
      U = f(b, a)
      o5 = [f(b,a)/U]


o = o3 * o4 * o5 = [U/X, b/Y, f(b,a)/U]
X = U, Y = b, U = f(b,a)
\end{verbatim}

\noindent\textbf{Note: Sigma Symbol was not working in Verbatim, thus a simple lowercase o was subsitituted.}

\noindent\newline\newline For number 2 of question 1 I got the following answer:

\begin{verbatim}
2. f(g(U),f(X,Y)) = f(X,f(Y,U))

  1. g(U) = X
       o1 = [g(U)/X]

  2. f(X,Y) = f(Y,U)
       3. X = Y
          o3 = [Y/X]
       4. Y = U
          o4 = [U/Y]

o = o1 * o2 * o3 = [X/U, Y/X, g(Y)/Y]
\end{verbatim}

\noindent\newline\newline For number 3 of question 1 I got the following answer:
\begin{verbatim}
3. h(U,f(g(V),W),g(W)) = h(f(X,b),U,Z)

  1. U = f(X,b)
     o1 = [f(X,b)/U]

  2. f(g(V),W) = U
     o2 = [f(g(V),W)/U]

  3. g(W) = Z
     o3 = [g(W)/Z]

  4. U(o1 * o2) --> f(X,b) = f(g(V),W)

     5. X = g(V)
        o5 = [g(V)/X]

     6. b = W
        o6 = [b/W]

  7. Z(o3 * o6) = g(W), W = b
     o7 = [g(b)/Z]

  8. U(o1 * o2 * o6) --> f(X,b) = f(g(V), b)
     o8 [f(g(V),b)/U]


  o = o5 * o6 * o7 * o8 = [f(g(V),b)/U, g(V)/X, b/W, g(b)/Z]


  U = f(g(V),b), W = b, X = g(V), Z = g(b)
\end{verbatim}

\subsubsection{Question 2}
For question 2, the task was to draw a SLD Recursion Tree for the following:\newline
\includegraphics[scale=0.65]{f}\newline\newline\newline

\noindent I got the following SLD Tree:
\begin{verbatim}



                   twoway(W,a)
                  /           \
                 /             \
              conn(W,a)        conn(a,W)
              /        \        /       \
            W=b        W=d   W=c       no
                        |            /  |  \
                        no          b   d   c
\end{verbatim}

\noindent\newline twoway(W,a) becomes conn(W,a) and conn(a,W) because of the rule twoway(X,Y):- conn(X,Y), conn(Y,X). This becomes the first part of the tree. Then for the conn(X,Y), it becomes conn(W,a). This side of the tree will split into W=b and W=d. W=d eventually fails because there is no serv(d). However, W=b is successful because we have addr(a,b) and a a serv(b), which allows for the conn(b,a) to be true. On the right side of the tree, we have conn(a,W). This will split into w=c and no. Since c holds the address of a, and b holds the address of c, and serv(b) exists, we can create a conn(a,c) because of these factors. We see in the equation addr(X,Z), serv(Z), addr(Z,Y) can be applied here. In our case it would look similar to addr(a,b) serv(b) addr(b,c), which allows conn(b,c) to be true.


\subsection{Week 6 (Homework 3)}
\noindent\newline The goal this week was to solve the following:

\includegraphics[scale=0.64]{abcd}\noindent\newline

\noindent\newline I split this into to two parts (Top and Bottom Questions).

\subsubsection{Part 1 (Top)}
\noindent\newline Here is my answer for number 1:

\includegraphics[scale=0.64]{hw6_1}\noindent\newline

\noindent\newline Here is my answer for number 2:

\includegraphics[scale=0.64]{hw6_2}\noindent\newline

\noindent\newline Here is my answer for number 3:

\includegraphics[scale=0.64]{hw6_3}\noindent\newline

\noindent\newline Here is my answer for number 4:

\includegraphics[scale=0.64]{hw6_4}\noindent\newline

\noindent\newline Here is my answer for number 5:

\includegraphics[scale=0.64]{hw6_5_1}\noindent\newline
\includegraphics[scale=0.64]{hw6_5_2}\noindent\newline

\noindent\newline Here is my answer for number 6:

\includegraphics[scale=0.64]{hw6_6}\noindent\newline
\includegraphics[scale=0.64]{hw6_6_2}\noindent\newline

\subsubsection{Part 1 (Bottom)}
\noindent\newline Here is my answer for number 1:

\includegraphics[scale=0.64]{hw6_bottom_1}\noindent\newline

\noindent\newline Here is my answer for number 2:

\includegraphics[scale=0.64]{hw6_bottom_2}\noindent\newline


\noindent Note: I had trouble converting some of the symbols I used in my .txt file in my Verbatim. I used many screenshots instead. I will add my .txt and .jpg's in a folder called homeworkMedia on github!


\subsection{Week 9}
This weeks tasks were to experiment with Spin, and solve 4 exercises.

\noindent\newline Formulas:
\begin{verbatim}
[]  (success && bobAlice -> aliceBob)
[]  (success && aliceBob -> bobAlice)
\end{verbatim}


\noindent\newline\textbf{Exercise 1:} 
Go through the program, find these variables, and describe in plain language the meaning of these propositions above.

\noindent\newline The 3 variables that will be discussed are success, bobAlice, and aliceBob. The variable success is a boolean variable. If the protocol runs to completion, then it will be set as 'True'. If it breaks somewhere down the line, then the protocol is not a 'success' and would be set to 'False'. The bobAlice variable is another boolean variable. If Bob receives a message from Alice then it would be set as 'True'. If Bob does not receive a message from Alice then it would be set as 'False'. Lastly, aliceBob is another boolean variable. If Alice receives a message from Bob then it would be set to 'True', if not then it would be 'False'.

\noindent\newline With all of these variables explained, the first formula would read if there is a success in the completion of the protocol and Bob is receives a message from Alice, then Bob is communicating with Alice. The next formula would read if there is a success in the completion of the protocol and Alice is receives a message from Bob, then Alice is communicating with Bob.


\noindent\newline\textbf{Exercise 2:} 
Which of the two formulas (from above) is verified as correct and which one is violated? What do we learn from this about the correctness of the protocol?

The second formula was verified as correct
\begin{verbatim}
[]  (success && aliceBob -> bobAlice)
\end{verbatim}

\noindent\newline While the first formula was violated
\begin{verbatim}
[]  (success && bobAlice -> aliceBob)
\end{verbatim}


\noindent\newline\newline This tells us that the variables \textbf{success} and \textbf{bobAlice} were True boolean variables. The variable \textbf{aliceBob} was False, and this formula would result in violated truth table, with 1 -> 0 being an outcome of 0 as well, meaning violated.

\noindent\newline Relevant Output (Violated Formula):
\begin{verbatim}
spin -a ns.pml; cc -o pan pan.c; ./pan -a

pan:1: assertion violated  
!( !(( !((((statusA==1)&&(statusB==1))&&(partnerB==10)))||(partnerA==9)))) (at depth 83)
pan: wrote ns.pml.trail

\end{verbatim}


\noindent\newline\textbf{Exercise 3:}
The property that is violated produces an execution sequence. How long is that execution sequence?

\noindent\newline The number of execution steps I read from my terminal using this command:
\begin{verbatim}
spin -p -t ns.pml
\end{verbatim}

\noindent was \textbf{84 execution sequences}. 

\noindent\newline Relevant Output:
\begin{verbatim}
vi ns.pml.trail

81:2:41
82:0:116
83:1:20
84:0:113
\end{verbatim}



\noindent\newline\textbf{Exercise 4:}
Use Spin to produce an MSC that represents a successful attack on the protocol. Explain in detail why the MSC constitutes a successful attack.


\noindent\newline These were the new propositional variable I created/used:
\begin{verbatim}
#define success		(statusA == ok && statusB == ok)
#define aliceBob	(partnerA == bob)
#define bobAlice	(partnerB == alice)
#define intruderAlice (partnerB == intruder)
#define intruderBob (partnerA == intruder)
#define bobIntruder (partnerA == bob)
#define aliceIntruder (partnerB== alice)
#define knowNA		(knowNA)
#define knowNB		(knowNB)
#define knownNI   (knowNI)
\end{verbatim}

\noindent\newline These were the formulas/properties I created:
\begin{verbatim}
ltl {[]  (success && aliceIntruder -> intruderAlice)}
ltl {[]  (success && intruderBob -> bobIntruder)}
ltl {[]  (success && bobIntruder -> intruderAlice)}
\end{verbatim}

\noindent\newline This was the output:
\begin{verbatim}
pan: ltl formula ltl_0
\end{verbatim}

\noindent\newline I was slightly confused in how to create a successful attack in Spin, but I believe that this worked and was classified as an \textbf{attack}. First, Alice sends a message to the Intruder. The Intruder then sends a message to Bob, where Bob then sends a message back to the Intruder. This means that the intruder would be able to impersonate both Bob and Alice. In theory, if Alice had access or control of Bob's money, the Intruder could send a message to get Bob's money from Alice by impersonating Bob. This would be a very bad attack on both Alice and Bob.


\noindent\newline To be considered a \textbf{successful attack}, the LTL-correctness properties are to be verified.

\ldots

\section{Paper}
\subsection{Introduction}

Prolog is a logic programming language that has many useful applications. Used in a wide range of fields, such as artificial intelligence, computational linguistics, and more, Prolog has proven to be a versatile language that can handle reasoning. This paper will explore the history, features, and applications of Prolog. Features that will be included in this paper will consist of logical paradigm, unification, backtracking, and pattern matching, which all play vital roles for the success of Prolog. Applications such as natural language process, expert systems, and automated planning will be examined through an algorithm analysis. Comparisons of common languages such as Java, C++, and Python will also be made versus Prolog to get a better understanding of the importance for the relatively unknown language. Highlighting the strengths and weaknesses of Prolog in an algorithm analysis and comparison will allow Prolog to be used more efficiently and correctly. With this information, the possibilities of Prolog for future development will be more clear for the reader. This paper will examine important aspects of Prolog to showcase the value it brings to software developments and its ability to solve complex problems with relative ease.\newline


\subsection{Background}
Prolog was created in the early 1970â€™s by French computer scientist Alan Colmerauer and Phillip Roussel in Marseille, France \href{https://www.cleverism.com/skills-and-tools/prolog/}{(1)}
, who both attended the University of Aix-Marseille. The two computer scientists had started working on a programming language that could handle reasoning and symbolic computation. While building the programming language, Colmerauer and Roussel collaborated with American-British computer scientist Robert Kowalski \href{http://www.doc.ic.ac.uk/~rak/papers/the.pdf}{(2)}. Kowalski had proposed the idea of a language based on Horn Clauses, which ended up being the basis of logical expressions in Prolog. In 1972, Roussel developed the first Prolog interpreter and artificial intelligence specialist David Warren created the first compiler \href{https://www.mta.ca/~rrosebru/oldcourse/371199/prolog/history.html#:~:text=1972}{(3)}, also known as Prolog I. This marked a significant milestone in the evolution of Prolog. Prolog, which stands for logic programming, also sometimes written as programming logic depending on who is asked, was aimed to be a programming language that was capable of handling reasoning and symbolic computation. Logic programming, uses logic to represent knowledge and the use of deduction to solve problems by deriving logical consequences \href{https://www.mta.ca/~rrosebru/oldcourse/371199/prolog/history.html#:~:text=1972}{(3)},. The language was made to be declarative3, a high-level programming language that specifies what is to be done, rather than how to do it \href{https://www.britannica.com/technology/declarative-language}{(4)}. In 1973, Prolog II was created, which has many of the common and important features we see in Prolog today \href{https://dl.acm.org/doi/pdf/10.1145/234286.1057820}{(5)}. This version of the language featured the use of backtracking \href{https://dl.acm.org/doi/pdf/10.1145/234286.1057820}{(5)} and unification, more on these features later. Over the years, Prolog continued to evolve and gain popularity, with new features and implementations being continually developed. Today there are many versions of Prolog, which include GNU Prolog and Sicstus Prolog. The most notable version is SWI-Prolog, which is open source \href{https://www.swi-prolog.org/}{(6)} and a community based version that highlights industry and degree use. The impact on the entire field of computer science cannot be overstated and allowed for advancements of artificial intelligence, natural language processing, and expert systems. Programming languages can seem to have some similarities or inspiration for Prolog, such as Haskell.

\subsection{Features}

\subsubsection{Logical Paradigm}
\noindent\newline Prolog has many important features that can be applied to different things. One feature that makes Prolog distinct from other programming languages is its logical paradigm. Logical paradigm takes a declarative approach to solving problems, with its knowledge being represented in logical rules \href{https://www.cs.ucf.edu/~leavens/ComS541Fall97/hw-pages/paradigms/major.html}{(1)}. As the program receives logical assertions based on various situations, prolog establishes them as facts. This idea is called Horn-Clauses. Logical rules created use Horn-Clauses to represent the rules and facts in the query written. Horn-Clauses have a head (left side) and a body (right side), but there are often times when there are headless Horn-Clauses which would disregard the head and only have the body \href{https://athena.ecs.csus.edu/~mei/logicp/prolog.html}{(2)}. Here is few examples of using logical rules being expressed as Horn-Clauses:
\begin{verbatim}
Headless Horn-Clauses:
cat(Bob)
cat(Bob, Leon)
\end{verbatim}

\noindent\newline The first script would tell us Bob is a Cat. 
\noindent\newline The next script would explain more, telling us that Bob is a cat owned by Leon. 

\begin{verbatim}
Headed Horn-Clauses:
animal(Bob):- cat(Bob, Leon)
\end{verbatim}

\noindent\newline This tells us that Bob is an animal, if Bob is a cat owned by Leon. 


\noindent\newline As you can see, the more rules and facts that get added, the more complicated the entire program will get for us to interpret. This is a huge reason why Prolog can be so useful because it can quickly identify relationships and solve the problem being asked. Many Prolog programs can be handled via pen and paper, but this would prove to be a much slower process than simply using the impressive programming language. 

\noindent\newline summary, the logical paradigm is a vital feature for Prolog. Providing Horn-Clauses and the basis for a declarative language, it solves user problems with relative ease. This feature is one of backings for the success of Prolog, and will continue to be. 

\noindent\newline To continue with the logical paradigm in Prolog, being a declarative programming language is another important aspect. In the Background, there was mention of Prolog being made to solve the task, rather than how to do the task. In conventional programming languages, an algorithm is formulated as a sequence of instructions that the computer must follow precisely in order to solve a problem \href{https://www.simplilearn.com/tutorials/data-structure-tutorial/what-is-an-algorithm}{(3)}. As previously mentioned, Horn-Clauses are used to create rules and facts in Prolog. Prolog uses these Horn-Clauses to create relationships between objects that the user created. The programmer will specify what it is they want to solve for, and Prolog will use the relationships, rules, and facts given and determine an answer. In some instances, depending on what is being asked, Prolog will answer the question with True, False, or many different data-types \href{https://medium.com/@donepudisreeharsha/data-types-abstraction-expressions-in-prolog-6c7251477677}{(4)}. 


\subsubsection{Unification}
Unification is another important feature that sets Prolog apart from typical programming languages. Unification involves comparing two terms to see if they are identical or can be made to be identical. If they are already identical, then unification can be made. If they are not, then a process called binding variables must be done in order to make the terms unify with each other \href{https://www.educba.com/prolog-unification/}{(5)}. Terms can be numbers, variables, atoms, or other structures. 

\noindent\newline When the process of unification between two terms takes place, Prolog will compare each term structure from left to right. When two constants are unified, Prolog will check if they are the same value. If they are not the same, then unification fails and the program backtracks, more on this later. If they are the same value, then unification is successful \href{https://www.dai.ed.ac.uk/groups/ssp/bookpages/quickprolog/node12.html}{(6)}. Here is an example:
\begin{verbatim}
?- a = a.
Yes

?- a = b.
No

\end{verbatim}

As you can see here, we know that a would be the same as a, and likewise that a is not the same as b. Prolog does this computation using unification, as mentioned above.

If they are not constants, but instead variables, Prolog binds them to the same value \href{https://www.dai.ed.ac.uk/groups/ssp/bookpages/quickprolog/node12.html}{(6)}. Here is an example:
\begin{verbatim}
?- X = a.
X = a
Yes

?- X = Y.
X = _UNIQUE
Y = _UNIQUE
Yes

\end{verbatim}

\noindent\newline Unification will bind these two variables to a single, unique variable name. Likely the variable would not be called \textbf{underscore UNIQUE} but instead possibly an underscore followed by a sequence of random-like numbers.  In Prolog, assignment of values to variables is different from typical programming languages. Instead of directly assigning the value to the variable, the variable is unified directly with the term. This means when the value of the term changes, the value of the variable changes as well \href{https://cliplab.org/~logalg/doc/The_Art_of_Prolog.pdf}{(7)}. Unification is also used to match a query with a rule or fact in the knowledge base. To determine if the query is true or false, the query will be unified with the rule or fact. If the result is true, then the unification process generates a set of values for the variables in the query. 

\noindent\newline The use of Unificication proves to be a vital feature of Prolog. By unifying constants, atoms, variables, and more, to make terms identical, it allows Prolog to represent and reason about knowledge and find an answer for the user.



\subsubsection{Backtracking}
\noindent\newline The next vital feature of Prolog that will be discussed is backtracking. Backtracking makes Prolog a much more powerful programming language because this concept allows Prolog to search multiple solutions and select the best. Backtracking allows Prolog to search for the truth value of different predicates by trying out various solutions and checking if they are correct \href{https://www.tutorialspoint.com/prolog/prolog_backtracking.htm#:~:text=Backtracking}{(8)}. While backtracking is not unique to only Prolog, fields such as Artificial Intelligence use the backtracking algorithm as well, it can be a super useful tool and has found success in the Prolog language.

\noindent\newline When the backtracking algorithm is computing, it will explore multiple paths of the search tree until a solution, or the best solution is found. When it runs into a leaf node with no solution found, the algorithm stores the current state of the program and will try another path. This will continue to occur until a solution is found, or every path has been taken \href{https://www.simplilearn.com/tutorials/data-structure-tutorial/backtracking-algorithm}{(9)}

\includegraphics[scale=0.64]{bactracking}\noindent\newline

\noindent\newline There are numerous advantages of the backtracking algorithm for use in Prolog. By exploring multiple solutions to a single problem, the best choice can be decided. In typical single-pass algorithms this would not be possible. Another advantage is that backtracking makes Prolog much more flexible. This means that code can be adjusted and changed, but the answer can still find the same exact solution with enough information. 

\noindent\newline One main disadvantage is the possible computation time. Since there could be a lot of rules and facts given to Prolog, and many different possibilities, a solution may take a long time to find. This also means that the search space of the algorithm is very large as well. Computationally efficient algorithms are very important to have, but in most cases Prolog does compute in a reasonable amount of time.

\noindent\newline\newline\textbf{Algorithm Analysis of Backtracking}
\noindent\newline The time complexity of Backtracking can be extremely good or bad. In theory, Backtracking can have a runtime of O(1) when a solution is found on the first trial. This means that when searching for a solution, it would be found on the very first leaf node. The actual act of backtracking never occurs, but this is still a case of backtracking. However, most of the time the solution is not found on the very first branch and leaf node, so the algorithm's time complexity gets worse. The worst case runtime would be O($2^n$). n in this case would be the number of decision points in the tree \href{https://athena.ecs.csus.edu/~mei/logicp/Programming_in_Prolog.pdf}{(10)}.



\subsubsection{Pattern Matching}
\noindent\newline The last Prolog feature that will be mentioned in this paper is pattern matching. Pattern matching is core feature of Prolog that allows manipulation of complex data with relative ease. Pattern matching is closely related and shares many of the same details and commands as Unification. The main difference is that Unification is the process of making two terms the same, while pattern matching is testing terms on a specific pattern \href{https://composingprograms.com/pages/45-unification.html}{(11)}. 

\noindent\newline The rules created by the user defines a pattern that can be followed. The pattern matching algorithm will determine if a set of terms matches the specific pattern. This will allow for the Prolog language as a whole to use new facts with other data. Simply, the program will be able match the new term to patterns that it has already defined from previous rules. Pattern matching is extremely important for Prolog, as Prolog follows the declarative programming paradigm that utilizes logical rules for defining relationships among entities. Pattern matching serves as an ideal algorithm to check if a specific input data works with a particular rule.


\noindent\newline\newline\textbf{Algorithm Analysis of Pattern Matching}
\noindent\newline Pattern matching's worst case runtime is a decent runtime. The Big-O notation would be O(n), where n is the length of the data being used to find a pattern. However, in the best case scenario, we can see a O(1). This case would be seen when the data and pattern are small and simple. As it gets more complex and the data expands, the runtime will go towards a linear runtime of O(n). 


\subsection{Applications}

\subsubsection{Natural Language Processing}
\noindent\newline Natural Language Processing, also known as NLP, is a field of computer science that focuses on giving machines the ability to comprehend text and write or speak similarly to humans \href{https://www.ibm.com/topics/natural-language-processing}{(1)}. Immediately, we  can see the connection to Artificial Intelligence from NLP. By combing computational linguistics, statistical analysis, and deep learning models, NLP allows computers to process human langauges by writing back in text or even speaking the human language. For example, common applications such as Apple's Siri and Amazon's Alexa use Natural Language Processing to speak back to the user \href{https://www.arm.com/glossary/natural-language-processing}{(2)}.

\noindent\newline Prolog has been used in many NLP applications, including text summarization, machine translation, chatbots, and speech recognition \href{https://monkeylearn.com/blog/natural-language-processing-applications/}{(3)}.

\noindent\newline The features of Prolog allow Natural Language Processing to be accelerated in some instances. By allowing developers to define rules and relationships, Prolog can correctly interpret user input phrases easily \href{https://www.cs.unm.edu/~luger/ai-final2/CH8_Natural%20Language%20Processing%20in%20Prolog.pdf}{(4)}. Again, since Prolog is a Declarative Programming Language, the answer the User is looking for would be given, rather than a list of programming steps. Prolog has been used in NLP applications that translate languages, retrieve information, and answer questions. 

\noindent\newline One of the main disadvantages of using Prolog for NLP applications is the lack of scalability for large NLP applications. As mentioned in the algorithm analysis of Pattern Matching, when the program gets larger and more complex, the runtime gets much worse from a constant runtime. NLP applications are very large because of all the data they must store, so many Prolog NLP applications could be slow. 

\subsubsection{Expert Systems}
\noindent\newline Expert Systems are another application that can be produced with the help of Prolog. Expert Systems are computer applications that provide advice or decision making assistance \href{https://www.britannica.com/technology/expert-system}{(5)}. Using two components, a knowledge base and an inference engine, the Expert System can use facts and relationships to determine an outcome for the user. The knowledge base and inference engine perfectly fit with the Prolog language. As mentioned previously, Prolog's logical rules, facts, relationships, and features will give an Expert System many tools to be efficient and accurate. 

\noindent\newline Expert Systems using Prolog can be used in medicine, finance, and engineering. For medical Expert Systems, medical officials and assisters can use the system to lookup symptoms for a patient, and receive a plausible diagnosis \href{https://journal.chestnet.org/action/showPdf?pii=S0012-3692%2815%2942851-X%}{(6)} In terms of finance, Expert Systems have efficiency in qualitiative analysis in profitability, baking, and strategic financial planning \href{https://www.routledge.com/Expert-Systems-in-Finance-Smart-Financial-Applications-in-Big-Data-Environments/Metawa-Elhoseny-Hassanien-Hassan/p/book/9780367729011}{(7)}. The use of Expert Systems are very important, but including Prolog can make the task of building it easier and more efficient. 


\subsubsection{Automated Planning}
\noindent\newline The last application that will be discussed is Automated Planning. Automated Planning uses rules and relationships to allow computers and machines to generate a sequence of actions in order to achieve a particular goal \href{https://cw.fel.cvut.cz/old/_media/courses/a4m33pah/planning-course.pdf}{(8)}. 

\noindent\newline The entire process  and application of Automated Planning is much more difficult than the others. Automated planning in Prolog involves using various techniques and algorithms such as heuristic search and constraint satisfaction. The planner generates a range of possible plans, assesses their feasibility according to certain constraints, and chooses the most optimal one. The process can be done manually or automatically, depending on the complexity of the problem.


\subsection{Language Comparison}
Language Comparison

\subsubsection{C++}
C++ Section

\subsubsection{Python}
Python Section

\subsubsection{Java}


\subsection{Conclusion}
Here is my conclusion.

...

\section{Conclusions}\label{conclusions}

(approx 400 words) A critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of software engineering? What did you find most interesting or useful? What improvements would you suggest?

\begin{thebibliography}{99}
\bibitem[ALG]{Alg} \href{https://github.com/alexhkurz/algorithm-analysis-2023}{Algorithm Analysis}, Chapman University, 2023.


Paper Sources: \newline
(1) \href{https://www.cleverism.com/skills-and-tools/prolog/}{a}\newline
(2) \href{http://www.doc.ic.ac.uk/~rak/papers/the%20early%20years.pdf}{b}\newline
(3) \href{https://www.mta.ca/~rrosebru/oldcourse/371199/prolog/history.html#:~:text=1972%20is%20referred%20to%20by,interpreter%20was%20built%20by%20Roussel.}{c}\newline
(4) \href{https://www.britannica.com/technology/declarative-language}{d} \newline
(5) \href{https://dl.acm.org/doi/pdf/10.1145/234286.1057820}{e} \newline
(6) \href{https://www.swi-prolog.org/}{f} \newline

Features Sesction:\newline
(1) \href{https://www.cs.ucf.edu/~leavens/ComS541Fall97/hw-pages/paradigms/major.html}{1}\newline
(2) \href{https://athena.ecs.csus.edu/~mei/logicp/prolog.html}{2}\newline
(3) \href{https://www.simplilearn.com/tutorials/data-structure-tutorial/what-is-an-algorithm}{3}\newline
(4) \href{https://medium.com/@donepudisreeharsha/data-types-abstraction-expressions-in-prolog-6c7251477677}{4}\newline
(5) \href{https://www.educba.com/prolog-unification/}{5}\newline
(6) \href{https://www.dai.ed.ac.uk/groups/ssp/bookpages/quickprolog/node12.html}{6}\newline
(7) \href{https://cliplab.org/~logalg/doc/The_Art_of_Prolog.pdf}{7}\newline
(8) \href{https://www.tutorialspoint.com/prolog/prolog_backtracking.htm#:~:text=Backtracking}{8}\newline
(9) \href{https://www.simplilearn.com/tutorials/data-structure-tutorial/backtracking-algorithm}{9}\newline
(10) \href{https://athena.ecs.csus.edu/~mei/logicp/Programming_in_Prolog.pdf}{10}\newline
(11) \href{https://composingprograms.com/pages/45-unification.html}{11}\newline

Applications Section:\newline
(1) \href{https://www.ibm.com/topics/natural-language-processing}{1}\newline
(2) \href{https://www.arm.com/glossary/natural-language-processing}{2}\newline
(3) \href{https://monkeylearn.com/blog/natural-language-processing-applications/}{3}\newline
(4) \href{https://www.cs.unm.edu/~luger/ai-final2/CH8_Natural%20Language%20Processing%20in%20Prolog.pdf}{4} \newline
(5) \href{https://www.britannica.com/technology/expert-system}{5}\newline
(6) \href{https://journal.chestnet.org/action/showPdf?pii=S0012-3692%2815%2942851-X}{6}\newline
(7) \href{https://www.routledge.com/Expert-Systems-in-Finance-Smart-Financial-Applications-in-Big-Data-Environments/Metawa-Elhoseny-Hassanien-Hassan/p/book/9780367729011}{7}\newline
(8) \href{https://cw.fel.cvut.cz/old/_media/courses/a4m33pah/planning-course.pdf}{8}\newline


\end{thebibliography}

\end{document}